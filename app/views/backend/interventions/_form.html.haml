
-# if !f.object.new_record? or procedure = Procedo[params[:procedure]]
- if procedure = f.object.reference
  = field_set do
    = f.input :reference_name, as: :hidden
    = f.referenced_association :production_support
    -#= f.referenced_association :production
    = f.input :started_at
    = f.input :stopped_at

  = field_set :casting do
    - if f.object.new_record? and f.object.casts.empty?
      - for name, variable in procedure.variables
        - f.object.casts.new(reference_name: name)
    = f.backend_fields_for :casts do |v|
      - reference = v.object.reference
      = v.input :reference_name, as: :hidden
      - if reference.new?
        = v.input("actor", :wrapper => :append, :value => 0, wrapper_html: {class: "inline special"}, label: reference.human_name) do
          = v.input_field :population
          - if reference.known_variant?
            %span.add-on= reference.variant_indication
          - else
            = v.referenced_association_field :variant, source: {scope: reference.scope_hash}
      - else
        = v.referenced_association :actor, label: reference.human_name, source: {scope: reference.scope_hash}

  -# field_set :operations do
    - if f.object.operations.empty? or f.object.new_record?
      - for id, operation in procedure.operations
        - f.object.operations.new(position: id)
    = f.backend_fields_for :operations do |v|
      = v.input :position, as: :hidden
      = v.input :started_at, label: v.object.reference.human_name, hint: v.object.reference.human_expressions.to_sentence
      -# = v.input :stopped_at, label: v.object.reference.human_name

  - if f.object.errors.count > 0
    = f.object.errors.messages.inspect


- else # Root Procedure Natures
  :ruby
    natures = []
    nature = Nomen::ProcedureNatures[params[:procedure_nature]]
    natures += (nature ? nature.children : Nomen::ProcedureNatures.roots)
    natures.delete_if{|n| Procedo.procedures_of_nature_and_its_children(n.name).empty?}
    can_go = false

  .proposal-list
    - if natures.any?
      - for n in natures
        - procedures = Procedo.procedures_of_nature(n.name.to_sym).sort{|a,b| a.human_name <=> b.human_name}
        - if procedures.size == 1
          - procedure = procedures.first
          - can_go = true
          = link_to(procedure.human_name, {reference_name: procedure.name, production_support_id: params[:production_support_id]}, class: "btn")
        - else
          = link_to(n.human_name, {procedure_nature: n.name, production_support_id: params[:production_support_id]}, class: "btn btn-important")
    - if nature
      - procedures = Procedo.procedures_of_nature(nature.name.to_sym)
      - if procedures.any?
        - can_go = true
        - for procedure in Procedo.procedures_of_nature(nature.name.to_sym).sort{|a,b| a.human_name <=> b.human_name}
          = link_to(procedure.human_name, {reference_name: procedure.name, production_support_id: params[:production_support_id]}, class: "btn")
  -# if can_go
    = field_set :duration do
      %p OK
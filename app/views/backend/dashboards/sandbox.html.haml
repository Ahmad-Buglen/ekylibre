:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby
  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    casts = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").last.casts
    casts.each do |ic| # InterventionCast
      res << Product.find(ic.actor) # unless ic.reference.new?
    end
    res
  end

  plowing_actors = actors_from_intervention('base-plowing-0')
  plowing = Procedo[:'base-plowing-0']

  aiosowing_actors = actors_from_intervention('base-all_in_one_sowing-0')
  all_in_one_sowing = Procedo[:'base-all_in_one_sowing-0']

  # loop Procedures > procedure p > actor a > variable v
  def relevance_by_actors(actors)
    relevant_procedures = Hash.new(0)
    Procedo.list.each do |k, procedure|
      actors.each do |actor|
        relevant_procedures[procedure.short_name] += 1 if possible_variables_matching(actor, procedure.variables.values).length > 0
      end
    end
    # at that step it should return a hash of procedures sorted by value, the
    # key being a procedure's name, the value being the number of matching actors
    relevant_procedures.sort_by{|k, v| -v}
  end

  # loop Procedures > procedure p > variable v > actor a
  def r_b_a(actors)
    relevant_procedures = Hash.new(0)
    Procedo.list.each do |k, procedure|
      procedure.variables.values.each do |variable|
        relevant_procedures[procedure.short_name] +=1 if possible_actors_matching(actors, variable).length > 0
      end
    end
    relevant_procedures.sort_by{|k,v| -v }
  end

  # params:   - actors, an array of actors we want to check
  #           - variable, a procedure variable for which we want to know who could comply with
  # return:   - result, an array of all the actors that might comply with the given variable
  def possible_actors_matching(actors, variable)
    result = []
      actors.each do |actor|
        result << actor if actor_matching_variable?(actor,variable)
      end
    result
  end

  # params:   - actor, an actor for which we want to check matching procedure's variables
  #           - variables, an array of variables from a procedure
  # return:   - result, an array of variables that might comply with the given actor
  def possible_variables_matching(actor, variables)
    result = []
    variables.each do |variable|
      result << variable if actor_matching_variable?(actor, variable)
    end
    result
  end

  def actor_matching_variable?(actor, variable)
    # first, comparing variety, derivative and abilities
    # 3 possible situations :
    #   - the procedure variable contains only the variety
    #     => we just check the variety
    return true if variable.variety == actor.variety && variable.derivative_of.nil? && variable.abilities.empty?
    #   - the procedure variable contains variety and derivative
    #     => we check both
    return true if variable.variety == actor.variety && variable.derivative_of == actor.derivative_of && variable.abilities.empty?
    #   - the procedure variable contains variety and/or derivative and abilities
    #     => we check everything
    return true if variable.variety == actor.variety && variable.derivative_of.nil? && is_able_of_everything?(actor, variable.abilities)
    return true if variable.variety == actor.variety && variable.derivative_of == actor.derivative_of && is_able_of_everything?(actor, variable.abilities)

    # then, if the previous step didn't match, try with abilities only
    return true if !variable.abilities.empty? && is_able_of_everything?(actor, variable.abilities)

    #default
    return false
  end

  def presence_of?(actor, procedure)
    procedure.variables.values.each do |variable|
      # first, comparing variety, derivative and abilities
      # 3 possible situations :
      #   - a procedure variable contains only the variety
      #     => we just check the variety
      return true if variable.variety == actor.variety && variable.derivative_of.nil? && variable.abilities.empty?
      #   - a procedure variable contains variety and derivative
      #     => we check both
      return true if variable.variety == actor.variety && variable.derivative_of == actor.derivative_of && variable.abilities.empty?
      #   - a procedure variable contains variety and/or derivative and abilities
      #     => we check everything
      return true if variable.variety == actor.variety && variable.derivative_of.nil? && is_able_of_everything?(actor, variable.abilities)
      return true if variable.variety == actor.variety && variable.derivative_of == actor.derivative_of && is_able_of_everything?(actor, variable.abilities)

      # then, if the previous step didn't match, try with abilities only
      return true if !variable.abilities.empty? && is_able_of_everything?(actor, variable.abilities)
    end
    # if we get here, we didn't find anything
    return false
  end

  def is_able_of_everything?(actor, abilities)
    if  abilities.length == 1 # case of the last ability to check
      return actor.able_to?(abilities[0])
    elsif !actor.able_to?(abilities[0])
      return false # it's useless to go on if one ability is missing
    end
    return actor.able_to?(abilities[0]) && is_able_of_everything?(actor, abilities.drop(1))
  end

  # generate labels for a matrix so we can write
  # "matrix[variable, actor] = value" instead of
  # "matrix[5, 3] = value"
  # params : items, an array of items for which we want to create labels
  # return : res, a hash associating an item (converted into sym) to an
  # integer being the number of its row or column in the matrix
  def labels_for(items)
    res = Hash.new
    items.inject(0){|i, item| res[item.name.to_sym] = i; i+=1}
    res
  end

  # generate a hash associating one actor to each variable
  # of a procedure.
  # params:   - variables, an array of procedure variables
  #           - actors, an array of actors possibly matching variables
  # return:   - result, a hash associating one actor to one variable
  #               key: variable, value: actor
  def associate_actors_to_variables(variables, actors)
    result = {}
    rows = labels_for variables
    cols = labels_for actors
    m = []
    rows.length.times do
      m << Array.new(cols.length, 0)
    end

    # generating arrays of actors matching each variable
    # and variables matching each actor
    actors_for_each_variable = Hash.new

    variables.each do |variable|
      actors_for_each_variable[variable.name.to_sym] = possible_actors_matching(actors, variable)
    end

    # filling matrix
    actors_for_each_variable.each do |var_key, actor_ary|
      actor_ary.each do |actor|
        m[rows[var_key]][cols[actor.name.to_sym]] = 1
      end
    end

    # managing matrix
    while m.reduce(0){|sum, row| sum += row.reduce(:+)} > 0
      current_variable = 0
      current_actor = 0

      # case of variables having only one actor matching
      while current_variable < m.length
        if m[current_variable].reduce(:+) == 1
          current_actor = m[current_variable].index(1)
          result[rows.key(current_variable)] = cols.key(current_actor)
          # we remove the current actor
          m.each{|row| row[current_actor] = 0}
          # we remove the current variable
          m[current_variable] = Array.new(cols.length, 0)
          # we return to the first line
          current_variable = 0
          current_actor = 0
        else
          current_variable += 1
        end
      end
      # no more variable with only one actor
      current_actor = 0
      while current_actor < cols.length
        column = []
        m.each {|row| column << row[current_actor]}
        column.flatten!
        if column.reduce(:+) == 1
          # we store the result
          result[rows.key(current_variable)] = cols.key(current_actor)
          # we remove the variable
          m[column.index(1)].fill(0)
          # we remove the actor
          m.each{|row| row[current_actor] = 0}
          # we return to the first line
          current_variable = 0
          break
        else
          current_actor += 1
        end
      end
      # no more variable with one actor, nor actor with one variable
      if current_actor >= cols.length
        rows.length.times do |n|
          result[rows.key(n)] ||= cols.key(m[n].index(1))
        end
      end
    end

    result
  end

  # result from draft code
  sowing_procedures = relevance_by_actors(aiosowing_actors)
  sowing_procedures2 = r_b_a(aiosowing_actors)

  # checking if code refactoring works properly
  plowing_result = nil #Intervention.match(plowing_actors)
  sowing_result = nil #Intervention.match(aiosowing_actors)

%h2 testing labels
count:
= labels_for(aiosowing_actors).count
%br
= labels_for(aiosowing_actors).inspect
%br
count:
= labels_for(all_in_one_sowing.variables.values).count
= labels_for(all_in_one_sowing.variables.values).inspect
%h2 testing matching
= associate_actors_to_variables(all_in_one_sowing.variables.values, aiosowing_actors).inspect


%h2 testing Nomen::
%h3 Nomen::Varieties
= Nomen::Varieties[:zea_bergxxon].parent.parent.parent.inspect

%h2 testing possible_actors_matching
%ul
- all_in_one_sowing.variables.values.each do |v|
  %li.key
    variable data:
    %br
    name:
    = v.name
    %br
    variety:
    = v.variety
    = v.variety.class
    %br
    derivative of:
    = v.derivative_of
    = v.derivative_of.class
    %br
    abilities:
    = v.abilities.inspect
  %li.result
    - possible_actors_matching(aiosowing_actors, v).each do |item|
      name:
      = item.name
      = item.name.class.superclass
      %br
      variety:
      = item.variety
      = item.variety.class.superclass
      %br
      derivative:
      = item.derivative_of
      = item.derivative_of.class.superclass
      %br
      abilities:
      = item.abilities.inspect
      %br
      %br
%h2 testing actor_matching_variable
%ul
- aiosowing_actors.each do |actor|
  %li.key
    actor:
    =actor.name
    %br
    = actor.class
  %li.result
    matching variables:
    - all_in_one_sowing.variables.values.each do |v|
      = v.inspect if actor_matching_variable?(actor, v)
%h2 procedures' match
%br
%h3 from relevance_by_actors
expected behavior: having 'base-plowing-0' among most relevant procedures
%br
= sowing_procedures.inspect
%br
%br
%h3 from r_b_a
expected behavior: should return the same result
%br
= sowing_procedures2.inspect


%h2  Actors inspection

%h3 all in one sowing

%ul
- aiosowing_actors.each do |a|
  %li.key
    Actor:
    = a.class
  %li
    abilities :
    = a.abilities.inspect
  %li
    variety:
    = a.variety
  %li
    derivative_of:
    = a.derivative_of
  %br
%br
%br

%h2 procedures inspection

%h3 all in one sowing
%ul
- all_in_one_sowing.variables.each do |k, v|
  %li.key
    = k
  %li
    variety:
    =v.variety
  %li
    derivative_of
    =v.derivative_of
  %li
    abilities:
    =v.abilities.inspect

%br
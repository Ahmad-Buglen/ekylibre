:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'logger'
  logger = Logger.new(STDOUT)
  logger.level = Logger::INFO

  require 'benchmark'

  ############################
  # generating data for test #
  ############################

  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    intervention = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").sample
    if intervention.present?
      intervention.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) unless ic.reference.new?
      end
    else
      return nil
    end
    res
  end

  # find all procedures from interventions involving given actors
  def procedures_for(*actors)
    actors.flatten!
    actors_id = []
    actors.each {|actor| actors_id << actor.id}
    res = Intervention.real.joins(:casts).
          where("intervention_casts.actor_id IN (#{actors_id.join(', ')})").
          group(:'interventions.reference_name').
          count(:'interventions.reference_name')
    res.sort_by{|k,v|-v}
  end

  product_ids = Product.pluck(:id)
  # select totally random actors
  random_actors = []
  10.times do
    random_actors << Product.find(product_ids.sample)
  end

  # generating actors arrays for every procedures for which there are
  # interventions in database
  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    if  actors_from_intervention(k).present?
      massive_test_hash[k] = actors_from_intervention(k)
    end
  end

  # select actors from a random intervention
  almost_random_actors = massive_test_hash.values.sample

  # listing procedures for which we have interventions
  intervention_list = []
  Procedo.list.keys.each do |procedure|
    intervention_list << procedure unless actors_from_intervention(procedure).blank?
  end
  
  rendering = false

- if rendering
  %h2 testing on individual random actors
  - random_actors.each do |actor|
    %h3
      = actor.name
    %ul
      - Intervention.match([actor], history: true, provisional: true).each do |procedure, relevance, arity|
        %li.variety
          = procedure.name
        %li.key
          relevance:
          = relevance
        %li.result
          arity:
          = arity
  %h2 testing on individual random actors having a history
  - almost_random_actors.each do |actor|
    %h3
      Actor:
      = actor.name
    %ul
      - Intervention.match([actor], history: true, provisional: true).each do |procedure, relevance, arity|
        %li.variety
          = procedure.name
        %li.key
          relevance:
          = relevance
        %li.result
          arity:
          = arity

  %h2 massive matching test on actual interventions actors 
  - massive_test_hash.each do |procedure_name, actors_ary|
    %h3 
      testing with actors from 
      = procedure_name
    %ul
      %li.bold
        Actors:
      - actors_ary.each do |actor|
        %li.key
          = actor.name
    %ul
      %li.italic
        Procedures:
      - Intervention.match(actors_ary, limit: 10, relevance: 0.2, history: true, provisional: true).each do |procedure, relevance, arity|
        %li.key 
          = procedure.name
        %li.result
          relevance: 
          = relevance
        %li.variety 
          arity: 
          = arity
            
  %h2 Benchmarks
  %h3 benchmarking #match with and without history
  %ul
    - Benchmark.bm do |bm|
      %li.key
        with 1 actor:
      %li.variety
        with history:
      %li.result
        = bm.report{Intervention.match([random_actors.first], history: true, provisional: true)} # remove quote"
      %li.variety
        without history:
      %li.result
        = bm.report{Intervention.match([random_actors.first])} # remove quote"
      %li.key 
        with 10 actors:
      %li.variety
        with history:
      %li.result
        = bm.report{Intervention.match(random_actors, history: true, provisional: true)} # remove quote"
      %li.variety
        without history:
      %li.result
        = bm.report{Intervention.match(random_actors)} # remove quote"

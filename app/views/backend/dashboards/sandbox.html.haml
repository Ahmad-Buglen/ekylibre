:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'logger'
  logger = Logger.new(STDOUT)
  logger.level = Logger::INFO

  require 'benchmark'

  ############################
  # generating data for test #
  ############################

  crumbs_data = []
  paths_data = []

  # raw crumbs
  Crumb.find_each do |crumb|
    shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      shape.circle(crumb.accuracy/50000)

              }
              crumbs_data << item
  end

  # crumbs grouped in paths
  # first actual intervention path (crumbs between first hard_start and first hard_stop)
  sql = ""
  sql << "  SELECT ST_AsEwkt(m.multiline) FROM("
  sql << "  SELECT ST_LineFromMultiPoint(multipoint.actual_job_path) AS multiline FROM"
  sql << "    ("
  sql << "      SELECT ST_Collect(actual_job.geolocation) AS actual_job_path FROM"
  sql << "      ("
  sql << "        SELECT id, read_at, nature, geolocation FROM crumbs"
  sql << "          WHERE read_at"
  sql << "          BETWEEN"
  sql << "            (SELECT read_at FROM crumbs WHERE nature = 'hard_start' ORDER BY read_at LIMIT 1)"
  sql << "          AND"
  sql << "            (SELECT read_at FROM crumbs WHERE nature = 'hard_stop' ORDER BY read_at LIMIT 1)"
  sql << "      ORDER BY read_at"
  sql << "      ) AS actual_job"
  sql << "    ) AS multipoint"
  sql << "  ) AS m"
  ActiveRecord::Base.connection.execute(sql).each do |path|
    job_path = path.values.first #Charta::Geometry.new(path, 4326)
    item = {
      name: 'actual job',
      shape: Charta::Geometry.new(job_path),
      nature: 'actual job',
      accuracy: 1.0
    }
    # paths_data << item
    # crumbs_data << item
  end

  # then the whole intervention i.e from start to stop
  sql = ""
  sql << "  SELECT ST_AsEwkt(m.multiline) FROM("
  sql << "  SELECT ST_LineFromMultiPoint(multipoint.actual_job_path) AS multiline FROM"
  sql << "    ("
  sql << "      SELECT ST_Collect(actual_job.geolocation) AS actual_job_path FROM"
  sql << "      ("
  sql << "        SELECT id, read_at, nature, geolocation FROM crumbs"
  sql << "          WHERE read_at"
  sql << "          BETWEEN"
  sql << "            (SELECT read_at FROM crumbs WHERE nature = 'start' ORDER BY read_at LIMIT 1)"
  sql << "          AND"
  sql << "            (SELECT read_at FROM crumbs WHERE nature = 'stop' ORDER BY read_at LIMIT 1)"
  sql << "      ORDER BY read_at"
  sql << "      ) AS actual_job"
  sql << "    ) AS multipoint"
  sql << "  ) AS m"

  ActiveRecord::Base.connection.execute(sql).each do |path|
    job_path = path.values.first #Charta::Geometry.new(path, 4326)
    item = {
      name: 'actual job',
      shape: Charta::Geometry.new(job_path),
      nature: 'whole intervention',
      accuracy: 1.0
    }
    # paths_data << item
    # crumbs_data << item
  end


  campaign = Campaign.currents.last
  data = []
  ProductionSupport.of_campaign(campaign).includes({production: [:activity, :campaign, :variant]}, :storage).find_each do |support|
    popup_content = []
    # for support

    popup_content << {label: :campaign.tl, value: support.production.campaign.name}
    popup_content << {label: :activity.tl, value: support.production.activity.name}
    popup_content << {label: :production_support.tl, value: link_to(support.name, backend_production_support_path(support))}

    if support_input_cost = support.input_cost and support_input_cost.to_d > 0.0
      popup_content << {label: :input_cost_per_hectare.tl, value: support_input_cost.to_s.to_f.round(2)}
    end

    if support_tool_cost = support.tool_cost and support_tool_cost.to_d > 0.0
      popup_content << {label: :tool_cost_per_hectare.tl, value: support_tool_cost.to_s.to_f.round(2)}
    end

    if support_time_cost = support.time_cost and support_time_cost.to_d > 0.0
      popup_content << {label: :time_cost_per_hectare.tl, value: support_time_cost.to_s.to_f.round(2)}
    end

    if params[:visualization] == "nitrogen_footprint"
      if nitrogen_concentration = support.nitrogen_balance and nitrogen_concentration.to_d != 0.0
        popup_content << {label: :nitrogen_concentration_per_hectare.tl, value: nitrogen_concentration.to_s.to_f.round(2)}
      end
      if phosphorus_concentration = support.phosphorus_balance and phosphorus_concentration.to_d != 0.0
        popup_content << {label: :phosphorus_concentration_per_hectare.tl, value: phosphorus_concentration.to_s.to_f.round(2)}
      end
      if potassium_concentration = support.potassium_balance and potassium_concentration.to_d != 0.0
        popup_content << {label: :potassium_concentration_per_hectare.tl, value: potassium_concentration.to_s.to_f.round(2)}
      end
    end

    if support.storage
      popup_content << {label: CultivableZone.human_attribute_name(:net_surface_area), value: support.storage.net_surface_area.in_hectare.round(2).l}
    end
    if interventions = Intervention.where(production_support: support).reorder(:started_at)
      popup_content << {label: :interventions_count.tl, value: interventions.count }
    end
    if interventions.count > 0 and last_intervention = interventions.last
      popup_content << {label: :last_intervention.tl, value: link_to( "NÂ°" + last_intervention.number, backend_intervention_path(last_intervention)) }
    end
    popup_content << render('popup', support: support)
    item = {
      name:       support.name,
      shape:      support.shape,
      campaign:   support.production.campaign.name,
      activity:   support.production.activity.name,
      production: support.production.name,
      variant:    support.production.variant.name,
      tool_cost:  support_tool_cost.to_s.to_f.round(2),
      input_cost: support_input_cost.to_s.to_f.round(2),
      time_cost:  support_time_cost.to_s.to_f.round(2),
      nitrogen_concentration:   nitrogen_concentration.to_s.to_f.round(2),
      phosphorus_concentration: phosphorus_concentration.to_s.to_f.round(2),
      potassium_concentration:  potassium_concentration.to_s.to_f.round(2),
      interventions_count: interventions.count,
      popup: {header: true, content: popup_content}
      }
    data << item
  end
  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    intervention = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").sample
    if intervention.present?
      intervention.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) unless ic.reference.new?
      end
    else
      return nil
    end
    res
  end

  # find all procedures from interventions involving given actors
  def procedures_for(*actors)
    actors.flatten!
    actors_id = []
    actors.each {|actor| actors_id << actor.id}
    res = Intervention.real.joins(:casts).
          where("intervention_casts.actor_id IN (#{actors_id.join(', ')})").
          group(:'interventions.reference_name').
          count(:'interventions.reference_name')
    res.sort_by{|k,v|-v}
  end

  product_ids = Product.pluck(:id)
  # select totally random actors
  random_actors = []
  10.times do
    random_actors << Product.find(product_ids.sample)
  end

  # generating actors arrays for every procedures for which there are
  # interventions in database
  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    if  actors_from_intervention(k).present?
      massive_test_hash[k] = actors_from_intervention(k)
    end
  end

  # select actors from a random intervention
  almost_random_actors = massive_test_hash.values.sample

  # listing procedures for which we have interventions
  intervention_list = []
  Procedo.list.keys.each do |procedure|
    intervention_list << procedure unless actors_from_intervention(procedure).blank?
  end

  # listing possibles products matching a point
  # using postgis operators on geometry objects
  # @param: crumb, a _Crumb object
  # @returns: an array of products whose shape contains the crumb
  # the method only matches plants, cultivable zones, building divisions or equipments
  def actors_containing(crumb)
    actors_id = ProductReading.where("geometry_value ~ (SELECT geolocation FROM crumbs WHERE id ='#{crumb.id}')").pluck(:product_id)
    Product.find(actors_id).
      delete_if{|actor| [Plant, CultivableZone, BuildingDivision, Equipment].
        inject(false){|one_of_previous, klass| actor.is_a?(klass) || one_of_previous} == false}
  end

  # detects possible production supports matching a point
  # using postgis operators on geometry objects
  # @param: crumb, a _Crumb object
  # @returns: an array of production supports whose shape contains the crumb among products involved in current campaigns
  def production_supports_containing(crumb)
    production_support_ids = ProductionSupport.joins(:campaign, :storage).
                              joins('INNER JOIN product_readings ON product_readings.product_id = products.id').
                              where("geometry_value ~ (SELECT geolocation FROM crumbs WHERE id ='#{crumb.id}')").pluck(:product_id)
    Product.find(production_support_ids)
  end

  # this method aims at identifying potential
  # procedures targets.
  # @params:  - crumbs, objects having a geolocation attribute Postgis can handle
  # @returns: - an array of Products among Animals, Plants or CultivableZones,
  #           whose shapes or container's shapes intersect the crumbs given in parameters
  # Hint: this method should give better results if crumbs between 'hard_start' and 'hard_stop' are
  # given in parameters
  def identify_possible_targets_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_containing(crumb).each do |actor|
        result << actor if actor.is_a? CultivableZone
        result << actor if actor.is_a? Plant
        # TODO: manage animal production. Hint: looking for buildingDivisions that contain animals
        if actor.is_a? BuildingDivision
          actor.contents.uniq.each do |content|
            result << content if content.is_a? Animal
          end
        end
      end
    end
    result.uniq
  end

  # this method aims at identifying potential
  # equipments for procedures
  # @params: - crumbs, objects having a geolocation attribute Postgis can handle.
  # @returns: - an array of equipments whose shape or container's shape
  #           intersect the crumbs given in parameters
  # Hint: this method should give better results if 'start' or 'stop' crumbs
  # are used, since the user is supposed to launch Rei from the place where
  # his equipments are stored and return back to that place at the end of the intervention
  def identify_possible_equipments_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_containing(crumb).each do |actor|
        result << actor if actor.is_a? Equipment
        if actor.is_a? BuildingDivision
          actor.contents.uniq.each do |content|
            result << content if content.is_a? Equipment
          end
        end
      end
    end
    result.uniq
  end

  hard_start_crumb = Crumb.where("nature = 'hard_start'").first
  hard_stop_crumb = Crumb.where("nature = 'hard_stop'").first
  start_crumb = Crumb.where("nature = 'start'").first
  stop_crumb = Crumb.where("nature = 'stop'").first

  actors_found_from_crumbs = []

  bat_genisse = Product.find(102)
  bat_stockage = Product.find(135)

  rendering = false 

- if rendering
  %h2 playing with maps
  = visualization do |v|
    - v.serie :main, data
    - v.serie :crumbs, crumbs_data
    - v.categories :activity, :main
    - v.categories :nature, :crumbs
    - v.background "OpenStreetMap.HOT"
    - v.background "Thunderforest.Transport"
    - v.background "Thunderforest.Outdoors"
    - v.control :zoom
    - v.control :scale
    - v.control :fullscreen
    - v.control :layer_selector

  %h2
    inspecting
    = bat_genisse.name
  %h3 inspecting content
  %ul
    - bat_genisse.contents.each do |content|
      %li.key
        = content.name
      %li.result
        class:
        = content.class
  %h2
    inspecting
    = bat_stockage.name
  %h3 inspecting content
  %ul
    - bat_stockage.contents.each do |content|
      %li.key
        = content.name
      %li.result
        class:
        = content.class
  %h2 inspecting everything matching start crumb
  %ul
    - actors_containing(start_crumb).each do |actor|
      %li.key
        = actor.name
      %li.result
        = actor.class
      - if actor.is_a? BuildingDivision
        - actor.contents.uniq.each do |content|
          %li.variety
            = content.name
          %li
            is an equipment?
            = content.is_a? Equipment
  %h2 possible equipments used:
  %h3 testing equipments deduction with start and stop crumbs
  %ul
    %li.result
      Dear user, did you use this?
    - identify_possible_equipments_from(start_crumb, stop_crumb).each do |equipment|
      %li.key
        = equipment.name
        - actors_found_from_crumbs << equipment
  %h2 possible targets
  %h3 testing target deduction with hard_stard and hard_stop crumbs
  %ul
    %li.result
      Dear user, did you work on this?
    - identify_possible_targets_from(hard_start_crumb, hard_stop_crumb).each do |target|
      %li.key
        = target.name
        - actors_found_from_crumbs << target
  %h2 Possible procedures matching
  %h3 testing intervention deduction with actors identified previously
  %ul
    %li
      Dear user, did you do one of these actions?
    - Intervention.match(actors_found_from_crumbs, history: true, provisional: true).each do |procedure, relevance, arity|
      %li.variety
        = procedure.name
      %li.key
        relevance:
        = relevance
      %li.result
        arity:
        = arity

:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'benchmark'

  activated = false
  if activated

  ############################
  # generating data for test #
  ############################

  actors_found_from_crumbs = []

  hard_start_crumb = Crumb.where("nature = 'hard_start'").first
  hard_stop_crumb = Crumb.where("nature = 'hard_stop'").first
  start_crumb = Crumb.where("nature = 'start'").first
  stop_crumb = Crumb.where("nature = 'stop'").first

  # Tries to guess all actors of a procedure from a trip.
  #
  # ==== Parameters:
  # - trip, a Trip object
  #
  # ==== What it does
  # this method first deduces the worker from crumbs' user_id.
  # It tries to deduce equipment from start and stop crumbs. If none was found it tries with
  # all crumbs between start and the first hard start or the 10 first crumbs if there's no hard_start
  # then it tries to deduce target plants, cultivable zones, building divisions, production supports or equipment
  # from hard_start and hard_stop crumbs if there are hard_start and hard_stop crumbs
  # finally, it tries to deduce all possible actors from all crumbs

  def actors_from(crumbs, options = {})
    start_stop_crumbs = crumbs.select{|crumb| crumb.nature == 'start' || crumb.nature == 'stop'}
    hard_start_crumbs = crumbs.select{|crumb| crumb.nature == 'hard_start'}
    actors = {}
    actors[:doer] = User.find(crumbs.first.user_id)
    actors[:equipment] = identify_possible_equipments_from(start_stop_crumbs)
    actors[:targets] = []
    hard_start_crumbs.each do |crumb|
      actors[:targets] << actors_matching(crumb, natures: [CultivableZone, Plant])
    end
    actors[:targets] = actors[:targets].flatten.uniq
    # actors[:production_supports] << nil
    # actors[:all]<< nil
    actors
  end

  # listing possibles products matching a point
  # using postgis operators on geometry objects
  # == params:
  #   - crumbs, an array of Crumb objects
  # == options
  #   - intersection: matches all actors intersecting the crumbs. Expects a boolean. Default false. By default
  #     the method returns only actors that include the crumbs.
  #   - natures: matches all actors whose nature is given. By default the method returns Plant, CultivableZone,
  #     BuildingDivision and Equipment objects.
  # @returns: an array of products whose shape contains or intersects the crumbs
  # the method only matches plants, cultivable zones, building divisions or equipment
  def actors_matching(crumbs, options = {})
    operator = '~'
    operator = '&&' if options[:intersection]
    options[:natures] ||= [Plant, CultivableZone, BuildingDivision, Equipment]
    crumbs = [crumbs].flatten
    crumbs_id = []
    crumbs.each {|crumb| crumbs_id << crumb.id }
    actors_id = ProductReading.
      where("geometry_value #{operator} (SELECT ST_Multi(ST_Collect(geolocation)) FROM (SELECT geolocation FROM crumbs WHERE id IN (#{crumbs_id.join(', ')})) AS m)").pluck(:product_id)
    Product.find(actors_id).
      delete_if{|actor| options[:natures].
      flatten.
      inject(false){|one_of_previous, klass| actor.is_a?(klass) || one_of_previous} == false}
  end

  # this method aims at identifying potential
  # procedures targets.
  # @params:  - crumbs, objects having a geolocation attribute Postgis can handle
  # @returns: - an array of Products among Animals, Plants or CultivableZones,
  #           whose shapes or container's shapes intersect the crumbs given in parameters
  # Hint: this method should give better results if crumbs between 'hard_start' and 'hard_stop' are
  # given in parameters
  def identify_possible_targets_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_matching([crumb]).to_a.each do |actor|
        result << actor if actor.is_a? CultivableZone
        result << actor if actor.is_a? Plant
        if actor.is_a? BuildingDivision
          actor.contains(:animal, crumb.read_at).to_a.each do |content|
            result << content
          end
        end
      end
    end
    result.uniq
  end

  # this method aims at identifying potential
  # equipments for procedures
  # @params: - crumbs, objects having a geolocation attribute Postgis can handle.
  # @returns: - an array of equipments whose shape or container's shape
  #           intersect the crumbs given in parameters
  # Hint: this method should give better results if 'start' or 'stop' crumbs
  # are used, since the user is supposed to launch Rei from the place where
  # his equipments are stored and return back to that place at the end of the intervention
  def identify_possible_equipments_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_matching([crumb]).to_a.each do |actor|
        if actor.is_a? BuildingDivision
          actor.contains.to_a.each do |localization|
            result << localization.product
          end
        end
      end
    end
    result.uniq.keep_if{|actor| actor.is_a? Equipment }
  end

  identify_possible_targets_from(hard_start_crumb, hard_stop_crumb).each do |target|
    actors_found_from_crumbs << target
  end

  identify_possible_equipments_from(start_crumb, stop_crumb).each do |equipment|
    actors_found_from_crumbs << equipment
  end

  crumbs_data = []
  hard_crumbs_data = []
  paths_data = []

  # raw crumbs
  Crumb.find_each do |crumb|
    begin
      shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      shape.circle(crumb.accuracy/50000)

              }
    rescue
      item = {}
    end
    crumbs_data << item
  end

  Crumb.where("nature IN ('start','stop', 'hard_start', 'hard_stop')").find_each do |crumb|
    #popup
    popup_content = []
    if ["start", "stop"].include?(crumb.nature)
      popup_content << render('actors', actors_list: identify_possible_equipments_from(crumb).uniq)
    else
      popup_content << render('actors', actors_list: identify_possible_targets_from(crumb).uniq)
    end

    begin
    shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      crumb.geolocation,
                popup: {header: false, content: popup_content}
            }
    rescue
      item = {}
    end
    hard_crumbs_data << item
  end

  def identify_production_supports_from(*crumbs)
    crumbs_id = []
    crumbs.flatten!
    crumbs.each {|crumb| crumbs_id << crumb.id }
    res = []
    where_clause = "geometry_value && (SELECT ST_Multi(ST_Collect(geolocation)) FROM "
    where_clause << "(SELECT geolocation FROM crumbs WHERE id IN (#{crumbs_id.join(', ')})) AS m)"
    ProductionSupport.of_campaign(Campaign.currents).includes({production: [:activity, :campaign, :variant]}, :storage)
      .joins(:storage)
      .joins("INNER JOIN product_readings ON products.id = product_readings.product_id")
      .where(where_clause)
  end

  data = []
  identify_production_supports_from(Crumb.all).find_each do |support|
    popup_content = []
    # for support

    popup_content << {label: :campaign.tl, value: support.production.campaign.name}
    popup_content << {label: :activity.tl, value: support.production.activity.name}
    popup_content << {label: :production_support.tl, value: link_to(support.name, backend_production_support_path(support))}

    if support_input_cost = support.input_cost and support_input_cost.to_d > 0.0
      popup_content << {label: :input_cost_per_hectare.tl, value: support_input_cost.to_s.to_f.round(2)}
    end

    if support_tool_cost = support.tool_cost and support_tool_cost.to_d > 0.0
      popup_content << {label: :tool_cost_per_hectare.tl, value: support_tool_cost.to_s.to_f.round(2)}
    end

    if support_time_cost = support.time_cost and support_time_cost.to_d > 0.0
      popup_content << {label: :time_cost_per_hectare.tl, value: support_time_cost.to_s.to_f.round(2)}
    end

    if params[:visualization] == "nitrogen_footprint"
      if nitrogen_concentration = support.nitrogen_balance and nitrogen_concentration.to_d != 0.0
        popup_content << {label: :nitrogen_concentration_per_hectare.tl, value: nitrogen_concentration.to_s.to_f.round(2)}
      end
      if phosphorus_concentration = support.phosphorus_balance and phosphorus_concentration.to_d != 0.0
        popup_content << {label: :phosphorus_concentration_per_hectare.tl, value: phosphorus_concentration.to_s.to_f.round(2)}
      end
      if potassium_concentration = support.potassium_balance and potassium_concentration.to_d != 0.0
        popup_content << {label: :potassium_concentration_per_hectare.tl, value: potassium_concentration.to_s.to_f.round(2)}
      end
    end

    if support.storage
      popup_content << {label: CultivableZone.human_attribute_name(:net_surface_area), value: support.storage.net_surface_area.in_hectare.round(2).l}
    end
    if interventions = Intervention.where(production_support: support).reorder(:started_at)
      popup_content << {label: :interventions_count.tl, value: interventions.count }
    end
    if interventions.count > 0 and last_intervention = interventions.last
      popup_content << {label: :last_intervention.tl, value: link_to( "NÂ°" + last_intervention.number, backend_intervention_path(last_intervention)) }
    end
    popup_content << render('popup', support: support, actors: actors_found_from_crumbs)
    item = {
      name:       support.name,
      shape:      support.shape,
      campaign:   support.production.campaign.name,
      activity:   support.production.activity.name,
      production: support.production.name,
      variant:    support.production.variant.name,
      tool_cost:  support_tool_cost.to_s.to_f.round(2),
      input_cost: support_input_cost.to_s.to_f.round(2),
      time_cost:  support_time_cost.to_s.to_f.round(2),
      nitrogen_concentration:   nitrogen_concentration.to_s.to_f.round(2),
      phosphorus_concentration: phosphorus_concentration.to_s.to_f.round(2),
      potassium_concentration:  potassium_concentration.to_s.to_f.round(2),
      interventions_count: interventions.count,
      popup: {header: true, content: popup_content}
      }
    data << item
  end

  all_actors = []
  all_actors << identify_possible_equipments_from(start_crumb, stop_crumb)
  all_actors << identify_possible_targets_from(hard_start_crumb, hard_stop_crumb)
  all_actors << User.find(start_crumb.user_id)

  # trip generator
  # a trip is a set of crumbs for one user (user_id field), ordered by read_at, between a start crumb and the stop crumb that follows
  # it contains one or several hard_start and hard_stop crumbs.
  def trip_generator
    buffer = []
    trash = []
    trips = []
    users = Crumb.all.pluck(:user_id).uniq
    states = [:initial, :trip_start, :trip, :trip_end, :work, :pause, :trash]
    natures = [:start, :point, :hard_start, :hard_stop, :pause, :resume, :stop]
    state = :initial
    former_state = nil

    # actions
    store = lambda {|crumb|buffer << crumb}
    trash_and_restart = lambda{|crumb|trash << buffer; buffer = []; store.call(crumb)}
    save_trip = lambda{|crumb|store.call(crumb); trips << buffer; buffer = []}
    pausing = lambda{|crumb|store.call(crumb); former_state = state}
    resuming = lambda{|crumb|store.call(crumb); state = former_state}

    # actions and state change table:
    # columns: current state
    # lines: current crumb's nature
    # in each cell: the action to make, the new state
    #
    #             | :initial      | :trip_start       | :trip             | :trip_end     | :work             | :pause            | :trash
    # -------------------------------------------------------------------------------------------------------------------------------------------
    # start       | store         | trash_and_restart | trash_and_restart | store         | trash_and_restart | trash_and_restart | trash_and_restart
    #             | -> trip_start | -> trip_start     | -> trip_start     | -> trip_start | -> trip_start     | -> trip_start     | -> trip_start
    # --------------------------------------------------------------------------------------------------------------------------------------------
    # point       | store         | store             | store             | store         | store             | store             | store
    #             | -> trash      | -> trip           | -> trip           | -> trash      | -> work           | -> trash          | -> trash
    # ------------------------------------------------------------------------------------------------------------------------------------------------
    # hard_start  | store         | store             | store             | store         | store             | store             | store
    #             | -> trash      | -> work           | -> work           | -> trash      | -> trash          | -> trash          | -> trash
    # ------------------------------------------------------------------------------------------------------------------------------------------------
    # hard_stop   | store         | store             | store             | store         | store             | store             | store
    #             | -> trash      | -> trash          | -> trash          | -> trash      | -> trip           | -> trash          | -> trash
    # ------------------------------------------------------------------------------------------------------------------------------------------
    # pause       | store         | pausing           | pausing           | store         | pausing           | store             | store
    #             | -> trash      | -> pause          | -> pause          | -> trash      | -> pause          | -> trash          | -> trash
    #-------------------------------------------------------------------------------------------------------------------------------------------
    # resume      | store         | store             | store             | store         | store             | resuming          | store
    #             | -> trash      | -> trash          | -> trash          | -> trash      | -> trash          | -> former state   | -> trash
    #-------------------------------------------------------------------------------------------------------------------------------------------
    # stop        | store         | store             | save_trip         | store         | store             | store             | store
    #             | -> trash      | -> trash          | -> trip_end       | -> trash      | -> trash          | -> trash          | -> trash
    #-------------------------------------------------------------------------------------------------------------------------------------------

    actions = [ [store,   trash_and_restart,  trash_and_restart,  store,  trash_and_restart,   trash_and_restart, trash_and_restart], # start
                [store,   store,              store,              store,  store,               store,             store            ], # point
                [store,   store,              store,              store,  store,               store,             store            ], # hard_start
                [store,   store,              store,              store,  store,               store,             store            ], # hard_stop
                [store,   pausing,            pausing,            store,  pausing,             store,             store            ], # pause
                [store,   store,              store,              store,  store,               resuming,          store            ], # resume
                [store,   store,              save_trip,          store,  store,               store,             store            ]  # stop
              ]

    state_change = [  [:trip_start, :trip_start, :trip_start, :trip_start,   :trip_start, :trip_start,  :trip_start ], # start
                      [:trash,      :trip,       :trip,       :trash,        :work,       :trash,       :trash      ], # point
                      [:trash,      :work,       :work,       :trash,        :trash,      :trash,       :trash      ], # hard_start
                      [:trash,      :trash,      :trash,      :trash,        :trip,       :trash,       :trash      ], # hard_stop
                      [:trash,      :pause,      :pause,      :trash,        :pause,      :trash,       :trash      ], # pause
                      [:trash,      :trash,      :trash,      :trash,        :trash,      former_state, :trash      ], # resume
                      [:trash,      :trash,      :trip_end,   :trash,        :trash,      :trash,       :trash      ]  # stop
                   ]

    users.each do |user|
      Crumb.where(user_id: user).order(read_at: :asc).each do |crumb|
        actions[natures.index(crumb.nature.to_sym)][states.index(state)].call(crumb)
        state = state_change[natures.index(crumb.nature.to_sym)][states.index(state)]
      end
      # cleaning buffer
      if buffer.present?
        trash << buffer
        buffer = []
      end
      state = :initial
    end

    result = {}
    result[:trips] = trips
    result[:trash] = trash
    result
  end

  end # 'activated' block

  rendering = activated

- if rendering
  %h2 inspecting
  %h3 actors from crumbs
  - trip_generator[:trips].each do |trip|
    - unless trip.blank?
      .bold
        inspecting crumbs
      %ul
        - trip.each do |crumb|
          %li.variety
            = crumb.nature if crumb.nature != 'point'
      .bold
        inspecting trip
      %ul
        - actors_from(trip).each do |key, value|
          %li.key
            = key
          %li.result
            - [value].flatten.each do |actor|
              = actor.name
              %br
  %h2 Fake show view
  = beehive do |b|
    -b.cell :map do
      = visualization do |v|
        - v.serie :main, data
        - v.serie :crumbs, crumbs_data
        - v.serie :hard_crumbs, hard_crumbs_data
        - v.categories :activity, :main
        - v.categories :nature, :crumbs
        - v.bubbles :accuracy, :hard_crumbs
        - v.background "OpenStreetMap.HOT"
        - v.background "Thunderforest.Transport"
        - v.background "Thunderforest.Outdoors"
        - v.control :zoom
        - v.control :scale
        - v.control :fullscreen
        - v.control :layer_selector
    - b.hbox do
      - b.cell :actors do
        = render 'actors', actors_list: all_actors.flatten
      - b.cell :works do
        = render 'works', procedures: Intervention.match(actors_found_from_crumbs, max_arity: true)
    - b.cell :interventions do
      = render 'interventions'


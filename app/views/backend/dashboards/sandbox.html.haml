:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  ############################
  # generating data for test #
  ############################
  require 'logger'
  logger = Logger.new(STDOUT)
  logger.level = Logger::INFO
  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    casts = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").last
    if !casts.nil?
      casts.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) unless ic.reference.new?
      end
    else
      return nil
    end
    res
  end


  # Struct for massive testing
  procedureData = Struct.new(:procedure, :actors)

  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    massive_test_hash[k.to_sym] = procedureData.new(Procedo[k.to_sym], actors_from_intervention(k.to_sym)) if actors_from_intervention(k.to_sym).present?
  end

  random_actors = []
  3.times do
    r = Random.new.rand(0..697)
    random_actors << Product.find(r)
  end

  allmost_random_actors = actors_from_intervention('base-all_in_one_sowing-0')[0..2]

  # listing procedures for which we have interventions
  intervention_list = []
  Procedo.list.keys.each do |procedure|
    intervention_list << procedure unless actors_from_intervention(procedure).nil?
  end

  #####################################
  # draft code
  #####################################

  #####################################
  # code for relevance sorting
  #####################################

  def match(actors, options = {})
    limit = options[:limit] || -1
    relevance_threshold = options[:relevance] || 0
    matchedProcedure = Struct.new(:procedure, :relevance, :arity)
    result = {}
    Procedo.list.each do |key, procedure|
      matched_variables = associate_actors_to_variables(procedure, actors)
      if matched_variables.count > 0
        result[key] = matchedProcedure.new(procedure,
                                          (matched_variables.values.count.to_f/actors.count),
                                           matched_variables.values.count)
      end
    end
    result.delete_if{|k, v| v.relevance < relevance_threshold}
    return result.sort_by{|k,v|-v.relevance}
  end

  # params:   - actors, an array of actors we want to check
  #           - variable, a procedure variable for which we want to know who could comply with
  # return:   - result, an array of all the actors that might comply with the given variable
  def possible_actors_matching(actors, variable)
    result = []
      actors.each do |actor|
        result << actor.name.to_sym if actor_matching_variable?(actor,variable)
      end
    return result
  end

  # params:   - actor, an actor for which we want to check matching procedure's variables
  #           - variables, an array of variables from a procedure
  # return:   - result, an array of variables that might comply with the given actor
  def possible_variables_matching(actor, variables)
    result = []
    variables.each do |variable|
      result << variable.name.to_sym if actor_matching_variable?(actor, variable)
    end
    result
  end

  def actor_matching_variable?(actor, variable)
    # we don't test created variables
    return false if variable.new?
    # logger.info("comparing #{actor.name} with #{variable.name}")
    result = nil
    if variable.variety.present?
      result = same_varieties?(actor, variable)
    end
    if variable.derivative_of.present? && actor.derivative_of.present?
      result = (result.nil?)? same_derivatives?(actor, variable):result && same_derivatives?(actor, variable)
    end
    if !variable.abilities.empty?
      result = (result.nil?)? is_able_of_everything?(actor, variable.abilities): result && is_able_of_everything?(actor, variable.abilities)
    end
    # default
    # logger.info("result: #{result}")
    return result || false
  end

  def same_varieties?(actor, variable)
    return same_item?(actor.variety, variable.variety)
  end

  def same_derivatives?(actor, variable)
    # logger.info("Derivatives: comparing #{actor.derivative_of} with #{variable.derivative_of}")
    return same_item?(actor.derivative_of, variable.derivative_of)
  end

  def same_item?(actor_item, variable_item)
    if actor_item == variable_item
      return true
    end
    actor_nomenclature_item = Nomen::Varieties[actor_item.to_sym]
    variable_nomenclature_item = Nomen::Varieties[variable_item.to_sym]

    if actor_nomenclature_item.present? && variable_nomenclature_item.present?
      return actor_nomenclature_item <= variable_nomenclature_item
    end
    return false

  end

  def is_able_of_everything?(actor, abilities)
    if  abilities.length == 1 # case of the last ability to check
      return actor.able_to?(abilities[0])
    elsif !actor.able_to?(abilities[0])
      return false # it's useless to go on if one ability is missing
    end
    return actor.able_to?(abilities[0]) && is_able_of_everything?(actor, abilities.drop(1))
  end

  #turns a hash {k1=>[v1, v2, v3,…], k2=>[v1, v3, vn,…]} into {v1=>[k1,kn],…}
  def reverse_hash_from(other)
    res = {}
    other.values.uniq.flatten.each{|v| res[v]=[]}
    other.map do |k,v|
      v.map do |w|
        res[w]<< k
      end
    end
    return res

  end

  # generate a hash associating one actor to each variable
  # of a procedure.
  # params:   - procedure, the procedure for which we intent to match actors with variables
  #           - actors, an array of actors possibly matching procedure variables
  #
  # return:   - result, a hash associating one actor to one variable
  #               key: variable, value: actor
  def associate_actors_to_variables(procedure, actors)
    variables = procedure.variables.values
    result = {}

    # generating arrays of actors matching each variable
    # and variables matching each actor
    actors_for_each_variable = Hash.new
    variables.each do |variable|
      actors_for_each_variable[variable.name.to_sym] = possible_actors_matching(actors, variable)
    end

    variables_for_each_actor = reverse_hash_from(actors_for_each_variable)

    # setting cursors
    current_variable = current_actor = 0

    while result.length != variables.length
      # before, cleaning variables with no actor
      actors_for_each_variable.each do |variable_key, actors_ary|
        if actors_ary.empty?
          result[variable_key] = nil
          actors_for_each_variable.delete(variable_key)
        end
      end
      # first, manage all variables having only one actor matching
      while current_variable < actors_for_each_variable.length
        current_variable_key = actors_for_each_variable.keys[current_variable]
        if actors_for_each_variable[current_variable_key].count == 1 && actors_for_each_variable[current_variable_key].present? # only one actor for the current variable
          result[current_variable_key] = actors_for_each_variable[current_variable_key].first
          # deleting actor from hash "actor => variables"
          variables_for_each_actor.delete(result[current_variable_key])
          # deleting actor for all remaining variables
          actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
          # removing current variable for all remaining actors
          variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
          # removing current variable from hash "variable => actors"
          actors_for_each_variable.delete(current_variable_key)
          # restart from the beginning
          current_variable = 0
        else
          current_variable += 1
        end
      end

      # then, manage first actor having only one variable matching and go back to the first step
      while current_actor < variables_for_each_actor.length
        current_actor_key = variables_for_each_actor.keys[current_actor]
        if variables_for_each_actor[current_actor_key].count == 1
          current_variable_key = variables_for_each_actor[current_actor_key].first
          result[current_variable_key] = current_actor_key
          # deleting actor from hash "actor => variables"
          variables_for_each_actor.delete(result[current_variable_key])
          # deleting actor for all remaining variables
          actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
          # removing current variable for all remaining actors
          variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
          # removing current variable from hash "variable => actors"
          actors_for_each_variable.delete(current_variable_key)
          # return to first step
          current_actor = 0
          break
        else
          current_actor += 1
        end
      end
      # then, manage the case when no actor has only one variable matching
      if current_actor == variables_for_each_actor.length
        current_variable = 0
        current_variable_key = actors_for_each_variable.keys[current_variable]
        result[current_variable_key] = actors_for_each_variable[current_variable_key].first unless actors_for_each_variable[current_variable_key].nil?
        # deleting actor from hash "actor => variables"
        variables_for_each_actor.delete(result[current_variable_key])
        # deleting actor for all remaining variables
        actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
        # removing current variable for all remaining actors
        variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
        # removing current variable from hash "variable => actors"
        actors_for_each_variable.delete(current_variable_key)
        # return to first step
      end

      # finally, manage the case when there's no more actor to match with variables
      if variables_for_each_actor.length == 0
        actors_for_each_variable.keys.each do |variable_key|
          result[variable_key] = nil
        end
      end

    end
    return result.delete_if{|k,v|v.nil?}
  end

  def v_for_each_a(actors, variables)
    variables_for_each_actor = Hash.new
    actors.each do |actor|
      variables_for_each_actor[actor.name.to_sym] = possible_variables_matching(actor, variables)
    end
    return variables_for_each_actor
  end

  def a_for_each_v(actors, variables)
    actors_for_each_variable = Hash.new
    variables.each do |variable|
      actors_for_each_variable[variable.name.to_sym] = possible_actors_matching(actors, variable)
    end
    return actors_for_each_variable
  end



%h2 massive testing on almost random actors
- k = intervention_list[rand(0...intervention_list.length)]
%h3
  = k
- actors = actors_from_intervention(k); lim = rand(-1..3); relevance = rand()
Actors:
%ul
- actors.each do |a|
  %li
    = a.name
Matching procedures:
%br
Parameters:
%ul
  %li
    limit:
    = lim
  %li
    relevance threshold:
    = relevance
%ul
- match(actors, {:limit=>lim, :relevance=> relevance}).each do |k, v|
  %li.key
    = k
  %li.result
    relevance:
    = v.relevance
  %li
    arity:
    = v.arity
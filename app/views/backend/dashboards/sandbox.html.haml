:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  ############################
  # generating data for test #
  ############################

  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    casts = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").last
    if !casts.nil?
      casts.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) # unless ic.reference.new?
      end
    else
      return nil
    end
    res
  end

  aiosowing_actors = actors_from_intervention('base-all_in_one_sowing-0')
  all_in_one_sowing = Procedo[:'base-all_in_one_sowing-0']

  corn_cultivation = Product.find(696)

  # Struct for massive testing
  procedureData = Struct.new(:procedure, :actors)

  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    massive_test_hash[k.to_sym] = procedureData.new(Procedo[k.to_sym], actors_from_intervention(k.to_sym)) if !actors_from_intervention(k.to_sym).nil?
  end


  #####################################
  # draft code
  #####################################

  #####################################
  # code for relevance sorting
  #####################################

  # loop Procedures > procedure p > actor a > variable v
  def relevance_by_actors(actors)
    relevant_procedures = Hash.new(0)
    Procedo.list.each do |k, procedure|
      actors.each do |actor|
        relevant_procedures[procedure.short_name] += 1 if possible_variables_matching(actor, procedure.variables.values).length > 0
      end
    end
    # at that step it should return a hash of procedures sorted by value, the
    # key being a procedure's name, the value being the number of matching actors
    relevant_procedures.sort_by{|k, v| -v}
  end

  # loop Procedures > procedure p > variable v > actor a
  def r_b_a(actors)
    relevant_procedures = Hash.new(0)
    Procedo.list.each do |k, procedure|
      procedure.variables.values.each do |variable|
        relevant_procedures[procedure.short_name] +=1 if possible_actors_matching(actors, variable).length > 0
      end
    end
    relevant_procedures.sort_by{|k,v| -v }
  end

  # params:   - actors, an array of actors we want to check
  #           - variable, a procedure variable for which we want to know who could comply with
  # return:   - result, an array of all the actors that might comply with the given variable
  def possible_actors_matching(actors, variable)
    result = []
      actors.each do |actor|
        result << actor.name.to_sym if actor_matching_variable?(actor,variable)
      end
    return result
  end

  # params:   - actor, an actor for which we want to check matching procedure's variables
  #           - variables, an array of variables from a procedure
  # return:   - result, an array of variables that might comply with the given actor
  def possible_variables_matching(actor, variables)
    result = []
    variables.each do |variable|
      result << variable.name.to_sym if actor_matching_variable?(actor, variable)
    end
    result
  end

  def actor_matching_variable?(actor, variable)
    result = nil
    if !variable.variety.nil?
      result = same_varieties?(actor, variable)
    end
    if !variable.derivative_of.nil? && !actor.derivative_of.nil?
      result = (result.nil?)? same_derivatives?(actor, variable):result && same_derivatives?(actor, variable)
    end
    if !variable.abilities.empty?
      result = (result.nil?)? is_able_of_everything?(actor, variable.abilities): result && is_able_of_everything?(actor, variable.abilities)
    end
    # default
    return result || false
  end

  def same_varieties?(actor, variable)
    return same_item?(actor.variety, variable.variety)
  end

  def same_derivatives?(actor, variable)
    return same_item?(actor.derivative_of, variable.derivative_of)
  end

  def same_item?(actor_item, variable_item)
    actor_nomenclature_item = Nomen::Varieties[actor_item.to_sym]
    variable_nomenclature_item = Nomen::Varieties[variable_item.to_sym]

    if !actor_nomenclature_item.nil? && !variable_nomenclature_item.nil?
      return actor_nomenclature_item <= variable_nomenclature_item
    end

    return actor_item == variable_item

  end

  def is_able_of_everything?(actor, abilities)
    if  abilities.length == 1 # case of the last ability to check
      return actor.able_to?(abilities[0])
    elsif !actor.able_to?(abilities[0])
      return false # it's useless to go on if one ability is missing
    end
    return actor.able_to?(abilities[0]) && is_able_of_everything?(actor, abilities.drop(1))
  end

  # generate a hash associating one actor to each variable
  # of a procedure.
  # params:   - variables, an array of procedure variables
  #           - actors, an array of actors possibly matching variables
  # return:   - result, a hash associating one actor to one variable
  #               key: variable, value: actor
  def associate_actors_to_variables(variables, actors)
    result = {}

    # generating arrays of actors matching each variable
    # and variables matching each actor
    actors_for_each_variable = Hash.new
    variables.each do |variable|
      actors_for_each_variable[variable.name.to_sym] = possible_actors_matching(actors, variable)
    end

    variables_for_each_actor = Hash.new
    actors.each do |actor|
      variables_for_each_actor[actor.name.to_sym] = possible_variables_matching(actor, variables)
    end

    # setting cursors
    current_variable = current_actor = 0

    while result.length != variables.length
      # first, manage all variables having only one actor matching
      while current_variable < actors_for_each_variable.length
        current_variable_key = actors_for_each_variable.keys[current_variable]
        if actors_for_each_variable[current_variable_key].count == 1 && !actors_for_each_variable[current_variable_key].nil? # only one actor for the current variable
          result[current_variable_key] = actors_for_each_variable[current_variable_key].first
          # deleting actor from hash "actor => variables"
          variables_for_each_actor.delete(result[current_variable_key])
          # deleting actor for all remaining variables
          actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
          # removing current variable for all remaining actors
          variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
          # removing current variable from hash "variable => actors"
          actors_for_each_variable.delete(current_variable_key)
          # restart from the beginning
          current_variable = 0
        else
          current_variable += 1
        end
      end

      # then, manage first actor having only one variable matching and go back to the first step
      while current_actor < variables_for_each_actor.length
        current_actor_key = variables_for_each_actor.keys[current_actor]
        if variables_for_each_actor[current_actor_key].count == 1
          current_variable_key = variables_for_each_actor[current_actor_key].first
          result[current_variable_key] = current_actor_key
          # deleting actor from hash "actor => variables"
          variables_for_each_actor.delete(result[current_variable_key])
          # deleting actor for all remaining variables
          actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
          # removing current variable for all remaining actors
          variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
          # removing current variable from hash "variable => actors"
          actors_for_each_variable.delete(current_variable_key)
          # return to first step
          current_actor = 0
          break
        else
          current_actor += 1
        end
      end
      # then, manage the case when no actor has only one variable matching
      if current_actor == variables_for_each_actor.length
        current_variable = 0
        current_variable_key = actors_for_each_variable.keys[current_variable]
        result[current_variable_key] = actors_for_each_variable[current_variable_key].first unless actors_for_each_variable[current_variable_key].nil?
        # deleting actor from hash "actor => variables"
        variables_for_each_actor.delete(result[current_variable_key])
        # deleting actor for all remaining variables
        actors_for_each_variable.values.each {|ary| ary.delete(result[current_variable_key])}
        # removing current variable for all remaining actors
        variables_for_each_actor.values.each {|ary| ary.delete(current_variable_key)}
        # removing current variable from hash "variable => actors"
        actors_for_each_variable.delete(current_variable_key)
        # return to first step
      end

      # finally, manage the case when there's no more actor to match with variables
      if variables_for_each_actor.length == 0
        actors_for_each_variable.keys.each do |variable_key|
          result[variable_key] = nil
        end
      end

    end
    return result
  end

%h2 massive testing
- massive_test_hash.each do |k, v|
  %h3
    = k
  = v.procedure.name
  %br
  %ul
  - associate_actors_to_variables(v.procedure.variables.values, v.actors).each do |k,v|
    %li.key
      = k
    %li.result
      = v
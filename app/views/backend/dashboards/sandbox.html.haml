:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'logger'
  logger = Logger.new(STDOUT)
  logger.level = Logger::INFO

  require 'benchmark'

  ############################
  # generating data for test #
  ############################

  crumbs_data = []

  Crumb.find_each do |crumb|
    shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      shape.circle(crumb.accuracy/50000)

              }
              crumbs_data << item
  end

  campaign = Campaign.currents.last
  data = []
  ProductionSupport.of_campaign(campaign).includes({production: [:activity, :campaign, :variant]}, :storage).find_each do |support|
    popup_content = []
    # for support

    popup_content << {label: :campaign.tl, value: support.production.campaign.name}
    popup_content << {label: :activity.tl, value: support.production.activity.name}
    popup_content << {label: :production_support.tl, value: link_to(support.name, backend_production_support_path(support))}

    if support_input_cost = support.input_cost and support_input_cost.to_d > 0.0
      popup_content << {label: :input_cost_per_hectare.tl, value: support_input_cost.to_s.to_f.round(2)}
    end

    if support_tool_cost = support.tool_cost and support_tool_cost.to_d > 0.0
      popup_content << {label: :tool_cost_per_hectare.tl, value: support_tool_cost.to_s.to_f.round(2)}
    end

    if support_time_cost = support.time_cost and support_time_cost.to_d > 0.0
      popup_content << {label: :time_cost_per_hectare.tl, value: support_time_cost.to_s.to_f.round(2)}
    end

    if params[:visualization] == "nitrogen_footprint"
      if nitrogen_concentration = support.nitrogen_balance and nitrogen_concentration.to_d != 0.0
        popup_content << {label: :nitrogen_concentration_per_hectare.tl, value: nitrogen_concentration.to_s.to_f.round(2)}
      end
      if phosphorus_concentration = support.phosphorus_balance and phosphorus_concentration.to_d != 0.0
        popup_content << {label: :phosphorus_concentration_per_hectare.tl, value: phosphorus_concentration.to_s.to_f.round(2)}
      end
      if potassium_concentration = support.potassium_balance and potassium_concentration.to_d != 0.0
        popup_content << {label: :potassium_concentration_per_hectare.tl, value: potassium_concentration.to_s.to_f.round(2)}
      end
    end

    if support.storage
      popup_content << {label: CultivableZone.human_attribute_name(:net_surface_area), value: support.storage.net_surface_area.in_hectare.round(2).l}
    end
    if interventions = Intervention.where(production_support: support).reorder(:started_at)
      popup_content << {label: :interventions_count.tl, value: interventions.count }
    end
    if interventions.count > 0 and last_intervention = interventions.last
      popup_content << {label: :last_intervention.tl, value: link_to( "NÂ°" + last_intervention.number, backend_intervention_path(last_intervention)) }
    end
    popup_content << render('popup', support: support)
    item = {
      name:       support.name,
      shape:      support.shape,
      campaign:   support.production.campaign.name,
      activity:   support.production.activity.name,
      production: support.production.name,
      variant:    support.production.variant.name,
      tool_cost:  support_tool_cost.to_s.to_f.round(2),
      input_cost: support_input_cost.to_s.to_f.round(2),
      time_cost:  support_time_cost.to_s.to_f.round(2),
      nitrogen_concentration:   nitrogen_concentration.to_s.to_f.round(2),
      phosphorus_concentration: phosphorus_concentration.to_s.to_f.round(2),
      potassium_concentration:  potassium_concentration.to_s.to_f.round(2),
      interventions_count: interventions.count,
      popup: {header: true, content: popup_content}
      }
    data << item
  end
  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    intervention = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").sample
    if intervention.present?
      intervention.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) unless ic.reference.new?
      end
    else
      return nil
    end
    res
  end

  # find all procedures from interventions involving given actors
  def procedures_for(*actors)
    actors.flatten!
    actors_id = []
    actors.each {|actor| actors_id << actor.id}
    res = Intervention.real.joins(:casts).
          where("intervention_casts.actor_id IN (#{actors_id.join(', ')})").
          group(:'interventions.reference_name').
          count(:'interventions.reference_name')
    res.sort_by{|k,v|-v}
  end

  product_ids = Product.pluck(:id)
  # select totally random actors
  random_actors = []
  10.times do
    random_actors << Product.find(product_ids.sample)
  end

  # generating actors arrays for every procedures for which there are
  # interventions in database
  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    if  actors_from_intervention(k).present?
      massive_test_hash[k] = actors_from_intervention(k)
    end
  end

  # select actors from a random intervention
  almost_random_actors = massive_test_hash.values.sample

  # listing procedures for which we have interventions
  intervention_list = []
  Procedo.list.keys.each do |procedure|
    intervention_list << procedure unless actors_from_intervention(procedure).blank?
  end

  # listing possibles products matching a point
  # using postgis operators on geometry objects
  # @param: crumb, a _Crumb object
  # @returns: an array of products whose shape contains the crumb among products involved in current campaigns
  def actors_containing(crumb)
    actors_id = ProductReading.where("geometry_value ~ (SELECT geolocation FROM crumbs WHERE id ='#{crumb.id}')").pluck(:product_id)
    Product.find(actors_id).sort_by{|product| product.contents.uniq.length}
  end

  hard_start_crumb = Crumb.where("nature = 'hard_start'").first

  rendering = false

- if rendering
  %h2 playing with maps
  = visualization do |v|
    - v.serie :main, data
    - v.serie :crumbs, crumbs_data
    - v.categories :activity, :main
    - v.categories :nature, :crumbs
    - v.background "OpenStreetMap.HOT"
    - v.background "Thunderforest.Transport"
    - v.background "Thunderforest.Outdoors"
    - v.control :zoom
    - v.control :scale
    - v.control :fullscreen
    - v.control :layer_selector

  %h2 inspecting actors_from crumb
  %h3 testing with hard start crumb:
  Actors containing crumb:
  %ul
    - actors_containing(hard_start_crumb).each do |actor|
      %li.key
        = actor.name if actor.respond_to? :name

  Possible procedures matching
  %ul
    - Intervention.match(actors_containing(hard_start_crumb), history: true, provisional: true).each do |procedure, relevance, arity|
      %li.variety
        = procedure.name
      %li.key
        relevance:
        = relevance
      %li.result
        arity:
        = arity

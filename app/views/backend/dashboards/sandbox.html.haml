:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'logger'
  logger = Logger.new(STDOUT)
  logger.level = Logger::INFO

  require 'benchmark'

  ############################
  # generating data for test #
  ############################

  # returns an array of actors from a real intervention example
  def actors_from_intervention(procedure_name)
    res = []
    intervention = Intervention.where("reference_name = '#{procedure_name}' AND state = 'done'").last
    if intervention.present?
      intervention.casts.each do |ic| # InterventionCast
        res << Product.find(ic.actor) unless ic.reference.new?
      end
    else
      return nil
    end
    return res
  end

  # find all procedures from interventions involving a given actor
  def procedures_for(actor)
    res = []
    Intervention.real.joins(:casts).where("intervention_casts.actor_id = #{actor.id}").each do |intervention|
      res << intervention.reference_name unless intervention.blank?
    end
    return res.flatten
  end

  history = []

  def provisional
    res = []
    Intervention.provisional.each do |intervention|
      res << intervention.reference_name
    end
    res
  end

  product_ids = Product.pluck(:id)
  # select totally random actors
  random_actors = []
  10.times do
    random_actors << Product.find(product_ids.sample)
  end

  # generating actors arrays for every procedures for which there are
  # interventions in database
  massive_test_hash = {}
  Procedo.list.keys.each do |k|
    if  actors_from_intervention(k).present?
      massive_test_hash[k] = actors_from_intervention(k)
    end
  end

  # select three actors from a random intervention
  almost_random_actors = massive_test_hash.values.sample
  if almost_random_actors.present?
    almost_random_actors.each do |actor|
      procedures_for(actor).each do |res|
        history << res
        history.flatten!
      end
    end
  end

  # listing procedures for which we have interventions
  intervention_list = []
  Procedo.list.keys.each do |procedure|
    intervention_list << procedure unless actors_from_intervention(procedure).blank?
  end
  
  rendering = false

- if rendering

  %h2 massive matching test on actual interventions actors 
  - massive_test_hash.each do |procedure_name, actors_ary|
    %h3 
      testing with actors from 
      = procedure_name
    %ul
      %li
        Actors:
      - actors_ary.each do |actor|
        %li.key
          = actor.name
    %ul
      %li
        Procedures:
      - Intervention.match(actors_ary, limit: 10, relevance: 0.2, history: true).each do |procedure, relevance, arity|
        %li.key 
          = procedure.name
        %li.result
          relevance: 
          = relevance
        %li.variety 
          arity: 
          = arity
            
  %h2 Benchmarks
  %h3 benchmarking #match with and without history
  %ul
    - Benchmark.bm do |bm|
      %li.key
        with 1 actor:
      %li.variety
        with history:
      %li.result
        = bm.report{Intervention.match([random_actors.first], history: true)} # remove quote"
      %li.variety
        without history:
      %li.result
        = bm.report{Intervention.match([random_actors.first])} # remove quote"
      %li.key 
        with 10 actors:
      %li.variety
        with history:
      %li.result
        = bm.report{Intervention.match(random_actors, history: true)} # remove quote"
      %li.variety
        without history:
      %li.result
        = bm.report{Intervention.match(random_actors)} # remove quote"

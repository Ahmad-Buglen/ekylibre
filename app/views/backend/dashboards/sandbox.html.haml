:css
  h2
  {
    font-weight: bolder;
    color: red;
  }

  h3
  {
    font-weight: bold;
    color: green;
  }
  .bold{font-weight: bold;}

  .italic{font-style: italic}

  .key
  {
    font-style: italic;
    color: blue;
  }

  .result
  {
    font-style: italic;
    color: purple;
  }

  .variety
  {
    color: orange;
  }



:ruby

  require 'benchmark'
  
  activated = true
  if activated 

  ############################
  # generating data for test #
  ############################

  actors_found_from_crumbs = []

  hard_start_crumb = Crumb.where("nature = 'hard_start'").first
  hard_stop_crumb = Crumb.where("nature = 'hard_stop'").first
  start_crumb = Crumb.where("nature = 'start'").first
  stop_crumb = Crumb.where("nature = 'stop'").first
  # listing possibles products matching a point
  # using postgis operators on geometry objects
  # @param: crumb, a _Crumb object
  # @returns: an array of products whose shape contains the crumb
  # the method only matches plants, cultivable zones, building divisions or equipments
  def actors_containing(crumb)
    actors_id = ProductReading.where("geometry_value ~ (SELECT geolocation FROM crumbs WHERE id ='#{crumb.id}')").pluck(:product_id)
    Product.find(actors_id).
      delete_if{|actor| [Plant, CultivableZone, BuildingDivision, Equipment].
        inject(false){|one_of_previous, klass| actor.is_a?(klass) || one_of_previous} == false}
  end

  # detects possible production supports matching a point
  # using postgis operators on geometry objects
  # @param: crumb, a _Crumb object
  # @returns: an array of production supports whose shape contains the crumb among products involved in current campaigns
  def production_supports_containing(crumb)
    production_support_ids = ProductionSupport.of_campaign(Campaign.currents.last).joins(:campaign, :storage).
                              joins('INNER JOIN product_readings ON product_readings.product_id = products.id').
                              where("geometry_value ~ (SELECT geolocation FROM crumbs WHERE id ='#{crumb.id}')").pluck(:product_id)
    Product.find(production_support_ids)
  end

  # this method aims at identifying potential
  # procedures targets.
  # @params:  - crumbs, objects having a geolocation attribute Postgis can handle
  # @returns: - an array of Products among Animals, Plants or CultivableZones,
  #           whose shapes or container's shapes intersect the crumbs given in parameters
  # Hint: this method should give better results if crumbs between 'hard_start' and 'hard_stop' are
  # given in parameters
  def identify_possible_targets_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_containing(crumb).to_a.each do |actor|
        result << actor if actor.is_a? CultivableZone
        result << actor if actor.is_a? Plant
        if actor.is_a? BuildingDivision
          actor.contains(:animal, crumb.read_at).to_a.each do |content|
            result << content
          end
        end
      end
    end
    result.uniq
  end

  # this method aims at identifying potential
  # equipments for procedures
  # @params: - crumbs, objects having a geolocation attribute Postgis can handle.
  # @returns: - an array of equipments whose shape or container's shape
  #           intersect the crumbs given in parameters
  # Hint: this method should give better results if 'start' or 'stop' crumbs
  # are used, since the user is supposed to launch Rei from the place where
  # his equipments are stored and return back to that place at the end of the intervention
  def identify_possible_equipments_from(*crumbs)
    crumbs.flatten!
    result = []
    crumbs.each do |crumb|
      actors_containing(crumb).to_a.each do |actor|
        if actor.is_a? BuildingDivision
          actor.contains.to_a.each do |localization|
            result << localization.product
          end
        end
      end
    end
    result.uniq.keep_if{|actor| actor.is_a? Equipment }
  end

  identify_possible_targets_from(hard_start_crumb, hard_stop_crumb).each do |target|
    actors_found_from_crumbs << target
  end

  identify_possible_equipments_from(start_crumb, stop_crumb).each do |equipment|
    actors_found_from_crumbs << equipment
  end

  crumbs_data = []
  hard_crumbs_data = []
  paths_data = []

  # raw crumbs
  Crumb.find_each do |crumb|
    begin
      shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      shape.circle(crumb.accuracy/50000)

              }
    rescue
      item = {}
    end
    crumbs_data << item
  end

  Crumb.where("nature IN ('start','stop', 'hard_start', 'hard_stop')").find_each do |crumb|
    #popup
    popup_content = []
    if ["start", "stop"].include?(crumb.nature)
      popup_content << render('actors', actors_list: identify_possible_equipments_from(crumb).uniq)
    else
      popup_content << render('actors', actors_list: identify_possible_targets_from(crumb).uniq)
    end

    begin
    shape = Charta::Geometry.new(crumb.geolocation)
    item = {
                name:       crumb.id,
                accuracy:   crumb.accuracy,
                nature:     crumb.nature,
                shape:      crumb.geolocation,
                popup: {header: false, content: popup_content}
            }
    rescue
      item = {}
    end
    hard_crumbs_data << item
  end

  ## crumbs grouped in paths
  ## first actual intervention path (crumbs between first hard_start and first hard_stop)
  #sql = ""
  #sql << "  SELECT ST_AsEwkt(m.multiline) FROM("
  #sql << "  SELECT ST_LineFromMultiPoint(multipoint.actual_job_path) AS multiline FROM"
  #sql << "    ("
  #sql << "      SELECT ST_Collect(actual_job.geolocation) AS actual_job_path FROM"
  #sql << "      ("
  #sql << "        SELECT id, read_at, nature, geolocation FROM crumbs"
  #sql << "          WHERE read_at"
  #sql << "          BETWEEN"
  #sql << "            (SELECT read_at FROM crumbs WHERE nature = 'hard_start' ORDER BY read_at LIMIT 1)"
  #sql << "          AND"
  #sql << "            (SELECT read_at FROM crumbs WHERE nature = 'hard_stop' ORDER BY read_at LIMIT 1)"
  #sql << "      ORDER BY read_at"
  #sql << "      ) AS actual_job"
  #sql << "    ) AS multipoint"
  #sql << "  #) AS m"
  #ActiveRecord::Base.connection.execute(sql).each do |path|
  #  job_path = path.values.first #Charta::Geometry.new(path, 4326)
  #  item = {
  #    name: 'actual job',
  #    shape: Charta::Geometry.new(job_path),
  #    nature: 'actual job',
  #    accuracy: 1.0
  #  }
  #  # paths_data << item
  #  crumbs_data << item
  #end

  ## then the whole intervention i.e from start to stop
  #sql = ""
  #sql << "  SELECT ST_AsEwkt(m.multiline) FROM("
  #sql << "  SELECT ST_LineFromMultiPoint(multipoint.actual_job_path) AS multiline FROM"
  #sql << "    ("
  #sql << "      SELECT ST_Collect(actual_job.geolocation) AS actual_job_path FROM"
  #sql << "      ("
  #sql << "        SELECT id, read_at, nature, geolocation FROM crumbs"
  #sql << "          WHERE read_at"
  #sql << "          BETWEEN"
  #sql << "            (SELECT read_at FROM crumbs WHERE nature = 'start' ORDER BY read_at LIMIT 1)"
  #sql << "          AND"
  #sql << "            (SELECT read_at FROM crumbs WHERE nature = 'stop' ORDER BY read_at LIMIT 1)"
  #sql << "      ORDER BY read_at"
  #sql << "      ) AS actual_job"
  #sql << "    ) AS multipoint"
  #sql << "  ) AS m"

  #ActiveRecord::Base.connection.execute(sql).each do |path|
  #  job_path = path.values.first #Charta::Geometry.new(path, 4326)
  #  item = {
  #    name: 'actual job',
  #    shape: Charta::Geometry.new(job_path),
  #    nature: 'whole intervention',
  #    accuracy: 1.0
  #  }
  #  # paths_data << item
  #  crumbs_data << item
  #end

  campaign = Campaign.currents.last
  data = []
  ProductionSupport.of_campaign(campaign).includes({production: [:activity, :campaign, :variant]}, :storage).find_each do |support|
    popup_content = []
    # for support

    popup_content << {label: :campaign.tl, value: support.production.campaign.name}
    popup_content << {label: :activity.tl, value: support.production.activity.name}
    popup_content << {label: :production_support.tl, value: link_to(support.name, backend_production_support_path(support))}

    if support_input_cost = support.input_cost and support_input_cost.to_d > 0.0
      popup_content << {label: :input_cost_per_hectare.tl, value: support_input_cost.to_s.to_f.round(2)}
    end

    if support_tool_cost = support.tool_cost and support_tool_cost.to_d > 0.0
      popup_content << {label: :tool_cost_per_hectare.tl, value: support_tool_cost.to_s.to_f.round(2)}
    end

    if support_time_cost = support.time_cost and support_time_cost.to_d > 0.0
      popup_content << {label: :time_cost_per_hectare.tl, value: support_time_cost.to_s.to_f.round(2)}
    end

    if params[:visualization] == "nitrogen_footprint"
      if nitrogen_concentration = support.nitrogen_balance and nitrogen_concentration.to_d != 0.0
        popup_content << {label: :nitrogen_concentration_per_hectare.tl, value: nitrogen_concentration.to_s.to_f.round(2)}
      end
      if phosphorus_concentration = support.phosphorus_balance and phosphorus_concentration.to_d != 0.0
        popup_content << {label: :phosphorus_concentration_per_hectare.tl, value: phosphorus_concentration.to_s.to_f.round(2)}
      end
      if potassium_concentration = support.potassium_balance and potassium_concentration.to_d != 0.0
        popup_content << {label: :potassium_concentration_per_hectare.tl, value: potassium_concentration.to_s.to_f.round(2)}
      end
    end

    if support.storage
      popup_content << {label: CultivableZone.human_attribute_name(:net_surface_area), value: support.storage.net_surface_area.in_hectare.round(2).l}
    end
    if interventions = Intervention.where(production_support: support).reorder(:started_at)
      popup_content << {label: :interventions_count.tl, value: interventions.count }
    end
    if interventions.count > 0 and last_intervention = interventions.last
      popup_content << {label: :last_intervention.tl, value: link_to( "N°" + last_intervention.number, backend_intervention_path(last_intervention)) }
    end
    popup_content << render('popup', support: support, actors: actors_found_from_crumbs)
    item = {
      name:       support.name,
      shape:      support.shape,
      campaign:   support.production.campaign.name,
      activity:   support.production.activity.name,
      production: support.production.name,
      variant:    support.production.variant.name,
      tool_cost:  support_tool_cost.to_s.to_f.round(2),
      input_cost: support_input_cost.to_s.to_f.round(2),
      time_cost:  support_time_cost.to_s.to_f.round(2),
      nitrogen_concentration:   nitrogen_concentration.to_s.to_f.round(2),
      phosphorus_concentration: phosphorus_concentration.to_s.to_f.round(2),
      potassium_concentration:  potassium_concentration.to_s.to_f.round(2),
      interventions_count: interventions.count,
      popup: {header: true, content: popup_content}
      }
    data << item
  end

  provisional_interventions = Intervention.provisional
  #provisional_interventions = Intervention.where("started_at > '#{Time.now - 3.months}'").limit(3)

  all_actors = []
  all_actors << identify_possible_equipments_from(start_crumb, stop_crumb)
  all_actors << identify_possible_targets_from(hard_start_crumb, hard_stop_crumb)
  
  end # 'activated' block

  # trip generator
  # a trip is a set of crumbs for one user (user_id field), ordered by read_at, between a start crumb and the stop crumb that follows
  # it contains one or several hard_start and hard_stop crumbs.
  def trip_generator
    users = Crumb.all.pluck(:user_id).uniq
    unqualified_crumbs_sets = {}
    
  end

  trips = trip_generator
  trip = {}
  trip[:number] = 1
  trip[:date] = '25/08/2014'
  trip[:km] = 42
  trip[:count] = 1

  rendering = activated

- if rendering

  = field_set do |b|
    -b.cell :map do
      = visualization do |v|
        - v.serie :main, data
        - v.serie :crumbs, crumbs_data
        - v.serie :hard_crumbs, hard_crumbs_data
        - v.categories :activity, :main
        - v.categories :nature, :crumbs
        - v.bubbles :accuracy, :hard_crumbs
        - v.background "OpenStreetMap.HOT"
        - v.background "Thunderforest.Transport"
        - v.background "Thunderforest.Outdoors"
        - v.control :zoom
        - v.control :scale
        - v.control :fullscreen
        - v.control :layer_selector
    - b.hbox do
      - b.cell :actors do
        = render 'actors', actors_list: all_actors.flatten
      - b.cell :works do
        = render 'works', procedures: Intervention.match(actors_found_from_crumbs, max_arity: true)
    - b.cell :interventions do
      = render 'interventions'
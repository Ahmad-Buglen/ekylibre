= f.object.errors.inspect if Rails.env.development? && f.object.errors.any?
= field_set do
  = f.input :sampled_at
  = f.referenced_association :activity, as: :hidden
  = f.referenced_association :product, source: :plants
  = f.input(:implanter_application_width, wrapper: :append) do
    = f.input_field(:implanter_application_width)
    %span.add-on= Nomen::Unit[:meter].l
  = f.input :implanter_rows_number
  = f.input(:sampling_distance, wrapper: :append) do
    = f.input_field(:sampling_distance)
    %span.add-on= Nomen::Unit[:meter].l
  = f.input(:net_surface_area_in_hectare, wrapper: :append) do
    = f.input_field(:net_surface_area_in_hectare)
    %span.add-on= Nomen::Unit[:hectare].l
  = f.input :comment, as: :text

- activity = f.object.activity
- if activity && activity.grading_checks.any?
  - checks = []
  - activity.grading_checks.order(:nature, :minimal_calibre_value, :quality_criterion_id).each do |activity_grading_check|
    - checks << f.object.checks.find_or_initialize_by(activity_grading_check_id: activity_grading_check.id)
  = field_set(:items) do
    .items
      %table
        %thead
          %tr
            %th
            %th= ProductGradingCheck.human_attribute_name(:name)
            - if f.object.measure_grading_items_count
              %th= ProductGradingCheck.human_attribute_name(:items_count)
            - if f.object.measure_grading_net_mass
              %th= ProductGradingCheck.human_attribute_name(:net_mass_value)
            - if f.object.measure_grading_sizes
              %th= ProductGradingCheck.human_attribute_name(:minimal_size_value)
              %th= ProductGradingCheck.human_attribute_name(:maximal_size_value)
        %tbody#items
          = f.simple_fields_for :checks, checks do |cf|
            = render 'check_fields', f: cf

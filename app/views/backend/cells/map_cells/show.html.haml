- activity_productions = ActivityProduction
- if @activity_production_ids
  - activity_productions = activity_productions.where(id: @activity_production_ids)
- data = []

- if @campaigns && activity_productions.where.not(support_shape: nil).any?
  :ruby
    # Ekylibre.profile("map_cell3") do
      sensor_data = []
      Sensor.find_each.group_by(&:model_euid).each do |model, sensors|
        items = sensors.map do |sensor|
          if sensor.analyses.last && sensor.analyses.last.geolocation
            analysis = sensor.analyses.last
            popup_lines = analysis.items.map do |item|
              next unless item.value.respond_to? :l
              { label: item.human_indicator_name, content: item.value.l }
            end

            battery = sensor.battery_level
            popup_lines << { label: sensor.human_attribute_name(:battery_level), content: battery.to_s } if battery.present?
            transmission = sensor.last_transmission_at
            popup_lines << { label: sensor.human_attribute_name(:last_transmission_at), content: transmission.localize } if transmission.present?

            bottom_line = ""
            bottom_line << "<span>#{link_to(:see_more_details.tl, sensor.partner_url)}</span>" if sensor.partner_url.present?
            bottom_line << "<i class='icon icon-battery-alert' style='color: red;'></i>" if sensor.alert_on? "battery_life"
            bottom_line << "<i class='icon icon-portable-wifi-off' style='color: red;'></i>" if sensor.alert_on? "lost_connection"
            popup_lines << ("<div style='display: flex; justify-content: space-between'>"+bottom_line+"</div>").html_safe
            header_content = "<span class='sensor-name'>#{sensor.name}</span>#{lights(sensor.alert_status)}".html_safe
            {
              sensor_id: sensor.id,
              name: sensor.name,
              shape: analysis.geolocation,
              shape_color: '#'+Digest::MD5.hexdigest(model)[0, 6].upcase,
              group: model.camelize,
              popup: {header: header_content, content: popup_lines }
            }
          end
        end

        sensor_data += (items || []).compact
      end

      activity_productions.of_campaign(@campaigns).includes(:activity, :interventions, :campaign, :cultivable_zone).find_each do |support|
        next unless support.support_shape
        popup_content = []

        popup_content << { label: ActivityProduction.human_attribute_name(:net_surface_area), value: support.human_support_shape_area }
        popup_content << { label: ActivityProduction.human_attribute_name(:activity), value: link_to(support.activity_name, backend_activity_path(support.activity)) }
        if support_input_cost = support.input_cost and support_input_cost.to_d > 0.0
          popup_content << {label: :costs_per_hectare.tl}
          popup_content << {value: "#{:inputs.tl} : #{support_input_cost.to_s.to_f.round(2)}"}
        end
        if support_tool_cost = support.tool_cost and support_tool_cost.to_d > 0.0
          popup_content << {value: "#{:tools.tl} : #{support_tool_cost.to_s.to_f.round(2)}"}
        end
        if support_time_cost = support.time_cost and support_time_cost.to_d > 0.0
          popup_content << {value: "#{:times.tl} : #{support_time_cost.to_s.to_f.round(2)}"}
        end

        surface_unit_name = :hectare

        grass_yield = nil
        grain_yield = nil

        # case fodder (hay, grass) in ton per hectare
        if support.usage == 'fodder' || support.usage == 'fiber'
          matter = :grass
          label = :grass_yield
          mass_unit_name = :ton
          grass_yield = support.harvest_yield(matter, procedure_category: :harvesting,
                            size_indicator_name: :net_mass,
                            size_unit_name: mass_unit_name,
                            surface_unit_name: surface_unit_name)
        # case grain in quintal per hectare
        elsif support.usage == 'grain' || support.usage == 'seed'
          matter = :grain
          label = :grain_yield
          mass_unit_name = :quintal
          grain_yield = support.harvest_yield(matter, procedure_category: :harvesting,
                            size_indicator_name: :net_mass,
                            size_unit_name: mass_unit_name,
                            surface_unit_name: surface_unit_name)
        else
          matter = :grain
          label = :grain_yield
          mass_unit_name = :quintal
          grain_yield = support.harvest_yield(matter, procedure_category: :harvesting,
                            size_indicator_name: :net_mass,
                            size_unit_name: mass_unit_name,
                            surface_unit_name: surface_unit_name)
        end

        if params[:visualization] == "grain_yield" && grain_yield && label
          popup_content << { label: label.tl, value: grain_yield.round(2).l }
        end

        interventions = support.interventions.real
        if interventions.any?
          spent_time = interventions.sum(:working_duration)
          popup_content << { label: :interventions_count.tl, value: "#{interventions.count} #{:during.tl.downcase!} #{:x_hours.tl(count: (spent_time/3600).round(2))}" }

          last_intervention = interventions.order(started_at: :desc).first
          popup_content << { label: :last_intervention.tl, value: link_to( last_intervention.name, backend_intervention_path(last_intervention)) }
        end

        popup_content << render('popup', production: support)

        item = {
          name:       support.name,
          shape:      support.support_shape,
          shape_color: support.activity.color,
          activity:   support.activity.name,
          tool_cost:  support.tool_cost.to_s.to_f.round(2),
          input_cost: support.input_cost.to_s.to_f.round(2),
          time_cost:  support.time_cost.to_s.to_f.round(2),
          interventions_count: interventions.count,
          grain_yield: grain_yield.to_s.to_f.round(2),
          grass_yield: grass_yield.to_s.to_f.round(2),
          popup: {header: true, content: popup_content}
        }
        data << item
      end
    # end


- if data.empty?
  .placeholding-message= :no_production_defined_for_current_campaign.tn
- else
  = visualization({}) do |v|
    - v.serie :main, data

    - unless sensor_data.blank?
      - v.serie :sensor_data, sensor_data
      - v.point_group :sensors, :sensor_data

    - if params[:visualization] == "nitrogen_footprint"
      - v.choropleth :interventions_count, :main
      - v.categories :activity, :main
    - elsif params[:visualization] == "grain_yield"
      - v.choropleth :grain_yield, :main, stop_color: "#E77000"
      - v.choropleth :grass_yield, :main, stop_color: "#00AA00"
      - v.categories :activity, :main
    - else
      - v.choropleth :tool_cost, :main, stop_color: "#00AA00"
      - v.choropleth :input_cost, :main, stop_color: "#1122DD"
      - v.choropleth :time_cost, :main, stop_color: "#E77000"
      - v.categories :activity, :main


    - v.control :zoom
    - v.control :scale
    - v.control :fullscreen
    - v.control :layer_selector
